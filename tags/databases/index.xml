<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Databases on Atwood&#39;s Blog</title>
    <link>http://atwoodwang.com/tags/databases/</link>
    <description>Recent content in Databases on Atwood&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 22 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://atwoodwang.com/tags/databases/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深入浅出 LevelDB (3) - SkipList 跳跃链表</title>
      <link>http://atwoodwang.com/2020/leveldb_skiplist/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://atwoodwang.com/2020/leveldb_skiplist/</guid>
      <description>Skiplist 介绍 上一篇我们提到, LevelDB中的数据是按照key的值进行有序存储的. LevelDB在内存中存储数据的区域称为memtable, 这个memtable底层是用跳跃链表skiplist来实现的. redis内部也采用跳跃链表来实现有序链表.
Skiplist的效率可以和AVL树, 红黑树媲美, 平均O(logN), 最坏O(N)的查询效率, 但是用Skiplist实现比平衡树实现简单许多, 所以很多程序用跳跃链表来代替平衡树.
Skiplist简单来说就是一个多层的单向链表, 是对一般我们所说的单向链表的补充.
这是一个单向链表, 如果我们想查找一个元素的话, 只能从头找到尾, 需要整个遍历一次, 时间为O(N)
如果是说链表是排序的, 并且节点中还存储了指向前面第二个节点的指针的话, 那么在查找一个节点时, 仅仅需要遍历N/2个节点即可. 这就是跳跃链表的核心, 利用不同节点间跳跃的指针, 来优化搜索的时间.
比如这个例子, 如果我们想搜索7, 比起单链表的从3到4到7, 在跳跃链表中, 我们从最高(最稀疏)层开始向下寻找, 直接可以通过4这个节点找到7. 如果我们想找寻14, 则通过12节点, 两步就可以搜索到了.
对于一个跳跃链表, 最下层就相当于一个普通的单向链表, 所有节点依次相连, 随着层数的增加, 每层里面的节点数逐渐减少. 搜索的时候, 从最高层开始寻找. 因为节点是有序的, 所以在搜索中一次就可以跨越多个无效节点, 大大节省时间.
源码分析 下面我们进入万众期待的源码分析环节!! 撒花~~
Node Skiplist数据结构在源码的skiplist.h文件里, 本身是一个类. 在看skiplist类本身之前, 我们先看看skiplist里面节点的定义.
Node结构里面主要有两个成员:
 key: 这个是skiplist节点的Key, 这个名字可能会比较让人迷惑, 因为LevelDB是一个键值数据库, 用户的插入操作会包含key和value, 第一次看这个部分的时候, 我一直在想node里面如果只存了key, 那用户传入的value存在哪里呢? 后来看了后面的代码才发现, Node的里面这个key, 和我们理解的用户插入的key, 是不一样的. 他实际上是包含了用户插入的键和值一起. 这里面具体的编码格式我们后面再说. std::atomic&amp;lt;Node*&amp;gt; next_[1]: 这是一个数组, 里面保存着当前节点下一点的指针.</description>
    </item>
    
    <item>
      <title>深入浅出 LevelDB (2) - Arena 内存池</title>
      <link>http://atwoodwang.com/2020/leveldb_arena/</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://atwoodwang.com/2020/leveldb_arena/</guid>
      <description>Arena 内存池 内存池的存在主要就是减少malloc或者new调用的次数, 较少内存分配所带来的系统开销, 提升性能.
LevelDB里自己实现了一个内存池, 它的做法是, 先向系统申请一块大的内存, 程序里需要申请内存时, 先把已有的内存块分配给用户, 如果不够用则再申请一块大的内存. 当内存池对象析构时, 分配的内存均被释放, 保证了内存不会泄漏.
Arena以block为单位来管理内存, 每个block的大小为4096KB.
先来看Arena类的结构
再来看具体的内部实现
Allocate inline char* Arena::Allocate(size_t bytes) { // The semantics of what to return are a bit messy if we allow  // 0-byte allocations, so we disallow them here (we don&amp;#39;t need  // them for our internal use). 最少也得申请一个byte  assert(bytes &amp;gt; 0); // 如果需要的内存小于剩余内存, 直接分配, 并且返回指针  if (bytes &amp;lt;= alloc_bytes_remaining_) { // 先保存当前指针偏移量, 用来返回  char* result = alloc_ptr_; // 增加指针偏移量, 为下次分配的起始点  alloc_ptr_ += bytes; // 剩余内存减少  alloc_bytes_remaining_ -= bytes; return result; } return AllocateFallback(bytes); } 可以看到, 如果当前block的剩余内存大于需要分配的内存, 直接分配即可, 如果当前block大小不够, 则进入AllocateFallback方法</description>
    </item>
    
    <item>
      <title>深入浅出 LevelDB (1) - 初识LevelDB</title>
      <link>http://atwoodwang.com/2020/leveldb_intro/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://atwoodwang.com/2020/leveldb_intro/</guid>
      <description>Intro 根据LevelDB官方介绍:
 LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.
 LevelDB是一个可持久化的KV数据库引擎，是大名鼎鼎的BigTable论文中描述的键值存储系统的单机版的实现, 它提供了一个极其高速的键值存储系统，并且由 Bigtable 的作者, Google传奇工程师Jeff Dean和Sanjay Ghemawat开发并开源。
主要特点如下:
 Keys and values are arbitrary byte arrays. 键和值都是任意长度的字节数组 Data is stored sorted by key. 内部存储是键值对的形式, 默认是按照键值的字典序进行排序. Callers can provide a custom comparison function to override the sort order. 用户可以提供自定义的排序方式 The basic operations are Put(key,value), Get(key), Delete(key). 提供基本操作接口, put(), get(), delete() Multiple changes can be made in one atomic batch.</description>
    </item>
    
  </channel>
</rss>